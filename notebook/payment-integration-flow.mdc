---
description: 
globs: 
alwaysApply: false
---
# PRD: One-Time Payment Integration with Razorpay & Supabase

**Version:** 1.0
**Date:** 2024-07-27
**Author:** AI Assistant

## 1. Introduction

This document outlines the requirements for implementing a one-time payment system for the Learnzy Pathway application. The goal is to allow users to make a single payment to unlock access to all learning cycles (current and future). This system will leverage Razorpay as the payment gateway and Supabase (Database, Auth, Edge Functions) as the backend infrastructure.

## 2. Goals

- Implement a secure and reliable one-time payment mechanism.
- Unlock access to all learning cycles for users who complete the payment.
- Provide a seamless user experience during the payment process.
- Utilize Supabase Edge Functions for secure backend payment logic.
- Integrate Razorpay for payment processing specific to the target region (likely India).

## 3. User Stories

- **As a logged-in user, I want to see an option to make a one-time payment to unlock all cycles, so that I can access all the learning content.**
- **As a user initiating payment, I want to be redirected to a secure Razorpay checkout page, so that I can enter my payment details confidently.**
- **As a user who has successfully paid, I want my access to all cycles to be granted automatically and immediately, so that I can start learning without delay.**
- **As a user who has successfully paid, I want my profile or dashboard to reflect my unlocked status, so that I have confirmation of my purchase.**
- **As an administrator, I want payment success and failures to be logged securely, so that I can troubleshoot issues if they arise.**

## 4. Functional Requirements

### 4.1. Payment Initiation

- **FR1.1:** Logged-in users without full access (`has_paid = false`) shall be presented with a clear Call-to-Action (CTA) button or link (e.g., "Unlock All Cycles", "Purchase Full Access") to initiate the payment process. This CTA could be on locked cycle cards, a dedicated pricing/upgrade page, or within the user's profile settings.
- **FR1.2:** Clicking the payment CTA shall trigger a request from the frontend to a dedicated Supabase Edge Function (`create-razorpay-order`).
- **FR1.3:** The `create-razorpay-order` Edge Function must verify the user is authenticated.

### 4.2. Razorpay Order Creation (Backend)

- **FR2.1:** The `create-razorpay-order` Edge Function shall use the Razorpay API (with secret keys stored securely in Supabase secrets) to create a payment order.
- **FR2.2:** The order details (amount, currency - likely INR) must correspond to the defined price for unlocking all cycles.
- **FR2.3:** The Supabase `user.id` must be included in the `notes` field or similar metadata when creating the Razorpay order. This is crucial for identifying the user later during verification.
- **FR2.4:** The Edge Function shall return the `order_id` generated by Razorpay, along with the Razorpay Key ID (public key), to the frontend.

### 4.3. Razorpay Checkout (Frontend)

- **FR3.1:** Upon receiving the `order_id` and Key ID from the Edge Function, the frontend shall initialize the Razorpay Web Checkout SDK.
- **FR3.2:** The checkout options must include:
  - `key`: The Razorpay Key ID.
  - `amount`: The payment amount (in the smallest currency unit, e.g., paise for INR).
  - `currency`: The currency code (e.g., "INR").
  - `name`: Application name (e.g., "Learnzy Pathway").
  - `description`: Purchase description (e.g., "One-time access to all cycles").
  - `order_id`: The ID received from the backend.
  - `handler`: A frontend JavaScript function to be called upon successful payment _on the client side_.
  - `prefill`: (Optional) User's name, email, contact number if available.
  - `notes`: (Optional) Can include `user_id` again for redundancy.
  - `theme`: Customize colors to match the app's branding.
- **FR3.3:** The Razorpay Checkout modal shall open, allowing the user to select a payment method and enter details.

### 4.4. Payment Verification (Client-Side & Backend)

- **FR4.1 (Client-Side Handler):** Upon successful payment within the Razorpay modal, the configured `handler` function in the frontend receives payment details including `razorpay_payment_id`, `razorpay_order_id`, and `razorpay_signature`.
- **FR4.2 (Client-Side Verification Request):** The frontend `handler` function **must immediately** send these three IDs (`razorpay_payment_id`, `razorpay_order_id`, `razorpay_signature`) to a _second_ Supabase Edge Function (`verify-razorpay-payment`) for server-side verification. **Crucially, do not grant access based _only_ on the client-side handler success.**
- **FR4.3 (Backend Verification):** The `verify-razorpay-payment` Edge Function shall:
  - Verify the user is authenticated.
  - Receive `razorpay_payment_id`, `razorpay_order_id`, `razorpay_signature` from the frontend request.
  - Use the Razorpay Node.js SDK and the **Razorpay Secret Key** (stored securely in Supabase secrets) to verify the payment signature. This involves reconstructing the signature based on the `order_id`, `payment_id`, and the secret key, and comparing it to the received `razorpay_signature`. **This step is critical for security.**
  - (Optional but recommended) Fetch the payment details from Razorpay using the `payment_id` to double-check the amount and status.
- **FR4.4 (Database Update):** If the signature verification is successful, the `verify-razorpay-payment` Edge Function shall:
  - Retrieve the Supabase `user.id` associated with the `razorpay_order_id` (likely by querying the original order details from Razorpay using the `order_id` or retrieving it from the order's `notes` if stored there).
  - Update the corresponding user's record in the `profiles` table in the Supabase database, setting `has_paid = true`.
  - (Optional) Store the `razorpay_payment_id` or `razorpay_order_id` in the user's profile for reference.
- **FR4.5 (Response to Frontend):** The `verify-razorpay-payment` Edge Function shall return a success or failure status to the frontend.

### 4.5. Post-Payment Experience

- **FR5.1:** Upon receiving success confirmation from the `verify-razorpay-payment` Edge Function, the frontend shall:
  - Redirect the user to a success page or update the UI dynamically.
  - Refresh user data/session state to reflect the `has_paid = true` status.
  - Unlock access to all cycles visually.
- **FR5.2:** If verification fails, the frontend shall display an appropriate error message to the user, advising them to contact support if they believe payment was successful.

### 4.6. Access Control

- **FR6.1:** Supabase Row Level Security (RLS) policies must be implemented on tables containing cycle content (e.g., `cycles`, `lessons`).
- **FR6.2:** The RLS policies for `SELECT` operations must check if the requesting authenticated user (`auth.uid()`) has `has_paid = true` in their linked `profiles` record. Users with `has_paid = false` should not be able to retrieve the protected content via direct API calls.

## 5. Non-Functional Requirements

- **NFR1 (Security):**
  - Razorpay API keys (Key ID and Secret) must be stored securely as Supabase environment variables/secrets and **never** exposed in the frontend code.
  - Payment verification **must** occur server-side using signature validation within a Supabase Edge Function.
  - Edge Functions handling payments must require user authentication where appropriate.
  - RLS policies must be enforced correctly to prevent unauthorized data access.
- **NFR2 (Reliability):** The system should handle potential Razorpay API outages or network errors gracefully, providing informative messages to the user. Implement retry logic for verification if appropriate, or clear instructions to contact support.
- **NFR3 (Performance):** Edge Function responses should be reasonably fast to avoid user frustration during the checkout process.
- **NFR4 (Scalability):** The solution using Supabase Edge Functions should scale reasonably well with user growth.
- **NFR5 (Error Handling & Logging):** Implement robust error handling in both frontend and Edge Functions. Log critical events (order creation, verification success/failure, errors) securely in Supabase (e.g., a dedicated `payments_log` table or using Supabase Logs) for debugging and auditing.

## 6. Technical Design Outline

### 6.1. Database Schema (`profiles` table extension)

```sql
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS has_paid BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS razorpay_order_id TEXT, -- Optional: Store last successful order ID
ADD COLUMN IF NOT EXISTS razorpay_payment_id TEXT; -- Optional: Store last successful payment ID
```

### 6.2. Supabase Edge Functions

- **`create-razorpay-order`:**
  - Method: POST
  - Auth: JWT (User must be logged in)
  - Input: (Implicit User ID from Auth)
  - Output: `{ orderId: string, keyId: string }` or `{ error: string }`
  - Dependencies: `supabase-js`, `razorpay` npm package, Supabase secrets for Razorpay keys.
- **`verify-razorpay-payment`:**
  - Method: POST
  - Auth: JWT (User must be logged in)
  - Input: `{ razorpay_payment_id: string, razorpay_order_id: string, razorpay_signature: string }`
  - Output: `{ success: boolean }` or `{ error: string }`
  - Dependencies: `supabase-js`, `razorpay` npm package, Node.js `crypto` module (for signature verification), Supabase secrets.

### 6.3. Razorpay Setup

- Obtain Razorpay API Key ID and Secret Key from the Razorpay Dashboard.
- Configure Supabase secrets for `RAZORPAY_KEY_ID` and `RAZORPAY_KEY_SECRET`.
- (Optional but Recommended) Configure a Razorpay Webhook endpoint pointing to a dedicated Supabase Edge Function (e.g., `razorpay-webhook-handler`) for events like `payment.failed`, `order.paid`. This provides a backup verification mechanism if the client-side flow fails. This webhook function would need its own signature verification.

### 6.4. Frontend Implementation

- Create a payment initiation component/button.
- Install Razorpay Checkout Web SDK.
- Implement API calls to the two Edge Functions (`create-razorpay-order`, `verify-razorpay-payment`).
- Implement the Razorpay `handler` function to trigger verification.
- Manage UI state based on payment status (`loading`, `success`, `error`).
- Update user context/state upon successful verification.

### 6.5. RLS Policy Example (on `cycles` table)

```sql
-- Ensure RLS is enabled on the table first
-- ALTER TABLE public.cycles ENABLE ROW LEVEL SECURITY;

-- Drop existing permissive policies if necessary
-- DROP POLICY IF EXISTS "Allow public read access" ON public.cycles;

CREATE POLICY "Allow paid users to read cycles"
ON public.cycles
FOR SELECT
USING (
  EXISTS (
    SELECT 1
    FROM public.profiles
    WHERE profiles.id = auth.uid() AND profiles.has_paid = true
  )
);
```

_(Adapt table/column names as needed)_

## 7. Success Metrics

- **Payment Completion Rate:** Percentage of users who initiate checkout and successfully complete payment.
- **Access Grant Rate:** Percentage of successful payments that result in the user's `has_paid` status being correctly updated.
- **Error Rate:** Frequency of errors during order creation or verification.
- **Support Tickets:** Number of support tickets related to payment issues.

## 8. Open Questions / Future Considerations

- **Specific Price:** Define the exact one-time payment amount and currency.
- **Refund Policy:** How will refunds be handled? (Requires manual process or further integration).
- **Webhook Implementation:** Decide whether to implement the optional Razorpay server-to-server webhook for added robustness.
- **Multiple Currencies/Regions:** Is support needed for users outside the primary Razorpay region? (Would require significant changes).
- **Failed Payments:** How to guide users who experience payment failures?
- **UI Design:** Finalize the design and placement of the payment CTAs and success/failure messages.

---

## 9. Implementation Plan

Based on analysis of the codebase, we need to make the following changes to implement the one-time payment system:

### 9.1. Database Changes

- ✅ Add `has_paid`, `razorpay_payment_id`, and `payment_date` columns to the `profiles` table (already done).

### 9.2. Supabase Edge Functions to Create

1. **create-razorpay-order.ts**

   ```typescript
   // supabase/functions/create-razorpay-order/index.ts
   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
   import Razorpay from 'https://esm.sh/razorpay@2.8.4'

   const corsHeaders = {
     'Access-Control-Allow-Origin': '*',
     'Access-Control-Allow-Headers':
       'authorization, x-client-info, apikey, content-type',
   }

   serve(async (req) => {
     // Handle OPTIONS request for CORS
     if (req.method === 'OPTIONS') {
       return new Response('ok', { headers: corsHeaders })
     }

     try {
       // Initialize Supabase client with auth context from request
       const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? ''
       const supabaseServiceKey =
         Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
       const supabase = createClient(supabaseUrl, supabaseServiceKey)

       // Get authenticated user
       const authHeader = req.headers.get('Authorization')!
       const {
         data: { user },
         error: authError,
       } = await supabase.auth.getUser(authHeader.split(' ')[1])

       if (authError || !user) {
         return new Response(
           JSON.stringify({ success: false, error: 'Unauthorized' }),
           {
             status: 401,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
           }
         )
       }

       // Initialize Razorpay client
       const rzp = new Razorpay({
         key_id: Deno.env.get('RAZORPAY_KEY_ID') ?? '',
         key_secret: Deno.env.get('RAZORPAY_KEY_SECRET') ?? '',
       })

       // Create Razorpay order
       const amount = 49900 // ₹499 in paise - adjust as needed
       const order = await rzp.orders.create({
         amount,
         currency: 'INR',
         receipt: `receipt_${Date.now()}_${user.id.substring(0, 8)}`,
         notes: {
           user_id: user.id,
         },
       })

       // Return order details to frontend
       return new Response(
         JSON.stringify({
           success: true,
           orderId: order.id,
           amount,
           currency: 'INR',
           keyId: Deno.env.get('RAZORPAY_KEY_ID'),
         }),
         { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
       )
     } catch (error) {
       console.error('Error creating order:', error)
       return new Response(
         JSON.stringify({
           success: false,
           error: error.message || 'Unknown error',
         }),
         {
           status: 500,
           headers: { ...corsHeaders, 'Content-Type': 'application/json' },
         }
       )
     }
   })
   ```

2. **verify-razorpay-payment.ts**

   ```typescript
   // supabase/functions/verify-razorpay-payment/index.ts
   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
   import Razorpay from 'https://esm.sh/razorpay@2.8.4'
   import { createHmac } from 'https://deno.land/std@0.168.0/node/crypto.ts'

   const corsHeaders = {
     'Access-Control-Allow-Origin': '*',
     'Access-Control-Allow-Headers':
       'authorization, x-client-info, apikey, content-type',
   }

   serve(async (req) => {
     // Handle OPTIONS request for CORS
     if (req.method === 'OPTIONS') {
       return new Response('ok', { headers: corsHeaders })
     }

     try {
       // Parse request body
       const { razorpay_payment_id, razorpay_order_id, razorpay_signature } =
         await req.json()

       if (!razorpay_payment_id || !razorpay_order_id || !razorpay_signature) {
         return new Response(
           JSON.stringify({
             success: false,
             error: 'Missing required parameters',
           }),
           {
             status: 400,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
           }
         )
       }

       // Initialize Supabase client with auth context from request
       const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? ''
       const supabaseServiceKey =
         Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
       const supabase = createClient(supabaseUrl, supabaseServiceKey)

       // Get authenticated user
       const authHeader = req.headers.get('Authorization')!
       const {
         data: { user },
         error: authError,
       } = await supabase.auth.getUser(authHeader.split(' ')[1])

       if (authError || !user) {
         return new Response(
           JSON.stringify({ success: false, error: 'Unauthorized' }),
           {
             status: 401,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
           }
         )
       }

       // Initialize Razorpay client
       const rzp = new Razorpay({
         key_id: Deno.env.get('RAZORPAY_KEY_ID') ?? '',
         key_secret: Deno.env.get('RAZORPAY_KEY_SECRET') ?? '',
       })

       // Verify payment signature
       const secret = Deno.env.get('RAZORPAY_KEY_SECRET') ?? ''
       const generatedSignature = createHmac('sha256', secret)
         .update(razorpay_order_id + '|' + razorpay_payment_id)
         .digest('hex')

       const isSignatureValid = generatedSignature === razorpay_signature

       if (!isSignatureValid) {
         return new Response(
           JSON.stringify({ success: false, error: 'Invalid signature' }),
           {
             status: 400,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
           }
         )
       }

       // Get order details to verify user_id in the notes
       const orderDetails = await rzp.orders.fetch(razorpay_order_id)

       // Additional verification: check if this order was created for this user
       if (orderDetails.notes.user_id !== user.id) {
         return new Response(
           JSON.stringify({
             success: false,
             error: 'Order not associated with authenticated user',
           }),
           {
             status: 403,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
           }
         )
       }

       // Update user profile to mark as paid
       const { error: updateError } = await supabase
         .from('profiles')
         .update({
           has_paid: true,
           razorpay_payment_id,
           payment_date: new Date().toISOString(),
         })
         .eq('id', user.id)

       if (updateError) {
         console.error('Error updating profile:', updateError)
         return new Response(
           JSON.stringify({
             success: false,
             error: 'Failed to update user profile',
           }),
           {
             status: 500,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
           }
         )
       }

       // Return success response
       return new Response(
         JSON.stringify({
           success: true,
           message: 'Payment verified and user profile updated',
         }),
         { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
       )
     } catch (error) {
       console.error('Error verifying payment:', error)
       return new Response(
         JSON.stringify({
           success: false,
           error: error.message || 'Unknown error',
         }),
         {
           status: 500,
           headers: { ...corsHeaders, 'Content-Type': 'application/json' },
         }
       )
     }
   })
   ```

### 9.3. Frontend Changes

1. **Create GlobalPaymentContext.tsx:**

   ```tsx
   // src/context/GlobalPaymentContext.tsx
   import React, { createContext, useContext, useState, useEffect } from 'react'
   import { useAuth } from './AuthContext'
   import { supabase } from '../lib/supabase'
   import { toast } from 'sonner'

   type GlobalPaymentContextType = {
     hasPaid: boolean
     isLoading: boolean
     initiateSinglePayment: () => Promise<void>
   }

   const GlobalPaymentContext = createContext<
     GlobalPaymentContextType | undefined
   >(undefined)

   export function GlobalPaymentProvider({
     children,
   }: {
     children: React.ReactNode
   }) {
     const { user } = useAuth()
     const [hasPaid, setHasPaid] = useState(false)
     const [isLoading, setIsLoading] = useState(true)
     const [showPaymentDialog, setShowPaymentDialog] = useState(false)

     // Load payment status
     useEffect(() => {
       if (user) {
         setIsLoading(true)
         supabase
           .from('profiles')
           .select('has_paid')
           .eq('id', user.id)
           .single()
           .then(({ data, error }) => {
             if (error) {
               console.error('Error fetching payment status:', error)
             } else {
               setHasPaid(data?.has_paid || false)
             }
             setIsLoading(false)
           })
       } else {
         setHasPaid(false)
         setIsLoading(false)
       }
     }, [user])

     const initiateSinglePayment = async () => {
       if (!user) {
         toast.error('You need to be logged in to make a payment')
         return
       }

       try {
         setIsLoading(true)
         // This function will be defined in src/utils/globalPayment.ts
         // We'll implement it next
         // Wait for implementation of the payment flow
         toast.info('Payment functionality is being implemented')
       } catch (error) {
         console.error('Payment error:', error)
         toast.error('An error occurred during payment processing')
       } finally {
         setIsLoading(false)
       }
     }

     return (
       <GlobalPaymentContext.Provider
         value={{
           hasPaid,
           isLoading,
           initiateSinglePayment,
         }}
       >
         {children}
       </GlobalPaymentContext.Provider>
     )
   }

   export function useGlobalPayment() {
     const context = useContext(GlobalPaymentContext)
     if (context === undefined) {
       throw new Error(
         'useGlobalPayment must be used within a GlobalPaymentProvider'
       )
     }
     return context
   }
   ```

2. **Create paymentService.ts:**

   ```typescript
   // src/services/payment/globalPayment.ts
   import { supabase } from '../../lib/supabase'
   import { loadRazorpayScript } from '../../utils/loadScript'

   interface PaymentResult {
     success: boolean
     paymentId?: string
     error?: string
   }

   /**
    * Create a Razorpay order using Supabase Edge Function
    */
   export const createGlobalRazorpayOrder = async (): Promise<{
     success: boolean
     orderId?: string
     amount?: number
     currency?: string
     keyId?: string
     error?: string
   }> => {
     try {
       // Call the Supabase Edge Function
       const { data, error } = await supabase.functions.invoke(
         'create-razorpay-order',
         {
           method: 'POST',
         }
       )

       if (error) throw error
       return data
     } catch (error) {
       console.error('Error in createGlobalRazorpayOrder:', error)
       return {
         success: false,
         error: error instanceof Error ? error.message : 'Unknown error',
       }
     }
   }

   /**
    * Verify a Razorpay payment using Supabase Edge Function
    */
   export const verifyGlobalRazorpayPayment = async (
     orderId: string,
     paymentId: string,
     signature: string
   ): Promise<boolean> => {
     try {
       // Call the Supabase Edge Function
       const { data, error } = await supabase.functions.invoke(
         'verify-razorpay-payment',
         {
           method: 'POST',
           body: {
             razorpay_order_id: orderId,
             razorpay_payment_id: paymentId,
             razorpay_signature: signature,
           },
         }
       )

       if (error) throw error
       return data.success
     } catch (error) {
       console.error('Error in verifyGlobalRazorpayPayment:', error)
       return false
     }
   }

   /**
    * Initiate full access payment with Razorpay
    */
   export const initiateGlobalPayment = async (): Promise<PaymentResult> => {
     try {
       // Ensure Razorpay is loaded
       await loadRazorpayScript()

       // Create order via Edge Function
       const orderData = await createGlobalRazorpayOrder()
       if (!orderData.success || !orderData.orderId) {
         throw new Error(orderData.error || 'Failed to create order')
       }

       // Return a promise that resolves when payment completes
       return new Promise((resolve) => {
         const rzp = new (window as any).Razorpay({
           key: orderData.keyId,
           amount: orderData.amount,
           currency: orderData.currency,
           name: 'Learnzy Pathway',
           description: 'Unlock All Learning Cycles',
           order_id: orderData.orderId,
           handler: function (response: any) {
             // Verify payment with our Edge Function
             verifyGlobalRazorpayPayment(
               response.razorpay_order_id,
               response.razorpay_payment_id,
               response.razorpay_signature
             ).then((verified) => {
               if (verified) {
                 resolve({
                   success: true,
                   paymentId: response.razorpay_payment_id,
                 })
               } else {
                 resolve({
                   success: false,
                   error: 'Payment verification failed',
                 })
               }
             })
           },
           prefill: {
             // Prefill user info if available from your auth context
           },
           theme: {
             color: '#FFB923', // Using learnzy-amber color
           },
           modal: {
             ondismiss: function () {
               resolve({ success: false, error: 'Payment cancelled by user' })
             },
           },
         })

         rzp.on('payment.failed', function (response: any) {
           resolve({
             success: false,
             error: response.error.description || 'Payment failed',
           })
         })

         rzp.open()
       })
     } catch (error) {
       console.error('Error in initiateGlobalPayment:', error)
       return {
         success: false,
         error: error instanceof Error ? error.message : 'Unknown error',
       }
     }
   }
   ```

3. **Update GlobalPaymentContext with the implementation:**

   ```typescript
   // In src/context/GlobalPaymentContext.tsx, update initiateSinglePayment:

   import { initiateGlobalPayment } from '../services/payment/globalPayment'

   // ...

   const initiateSinglePayment = async () => {
     if (!user) {
       toast.error('You need to be logged in to make a payment')
       return
     }

     try {
       setIsLoading(true)
       const result = await initiateGlobalPayment()

       if (result.success) {
         // Update local state
         setHasPaid(true)
         toast.success('Payment successful! You now have access to all cycles')
       } else {
         toast.error(result.error || 'Payment failed. Please try again.')
       }
     } catch (error) {
       console.error('Payment error:', error)
       toast.error('An error occurred during payment processing')
     } finally {
       setIsLoading(false)
     }
   }
   ```

4. **Create UnlockAllButton component:**

   ```tsx
   // src/components/payment/UnlockAllButton.tsx
   import React from 'react'
   import { Button } from '../ui/button'
   import { useGlobalPayment } from '../../context/GlobalPaymentContext'
   import { Sparkles } from 'lucide-react'

   interface UnlockAllButtonProps {
     variant?: 'default' | 'outline' | 'subtle' | 'prominent'
     size?: 'sm' | 'md' | 'lg'
     className?: string
   }

   const UnlockAllButton: React.FC<UnlockAllButtonProps> = ({
     variant = 'prominent',
     size = 'md',
     className = '',
   }) => {
     const { hasPaid, isLoading, initiateSinglePayment } = useGlobalPayment()

     if (hasPaid) return null

     // Map size to actual button sizes
     const buttonSizeClass =
       size === 'sm'
         ? 'px-3 py-1 text-sm'
         : size === 'lg'
         ? 'px-6 py-3 text-lg'
         : 'px-4 py-2'

     // Map variant to styles
     const buttonVariantClass =
       variant === 'outline'
         ? 'border border-amber-500 bg-transparent text-amber-500 hover:bg-amber-50'
         : variant === 'subtle'
         ? 'bg-amber-100 text-amber-800 hover:bg-amber-200'
         : variant === 'prominent'
         ? 'bg-gradient-to-r from-amber-500 to-amber-400 text-white shadow-md hover:from-amber-600 hover:to-amber-500'
         : 'bg-amber-500 text-white hover:bg-amber-600'

     return (
       <Button
         onClick={initiateSinglePayment}
         disabled={isLoading}
         className={`flex items-center gap-2 font-medium ${buttonSizeClass} ${buttonVariantClass} ${className}`}
       >
         {isLoading ? (
           <>
             <span className="animate-spin h-4 w-4 border-2 border-current border-t-transparent rounded-full"></span>
             Processing...
           </>
         ) : (
           <>
             <Sparkles className="h-4 w-4" />
             Unlock All Cycles
           </>
         )}
       </Button>
     )
   }

   export default UnlockAllButton
   ```

5. **Update App.tsx to include the GlobalPaymentProvider:**

   ```tsx
   // In src/App.tsx

   import { GlobalPaymentProvider } from './context/GlobalPaymentContext'

   // Inside your main app component:

   return (
     <AuthProvider>
       <GlobalPaymentProvider>{/* Rest of your app */}</GlobalPaymentProvider>
     </AuthProvider>
   )
   ```

6. **Create RLS Policy for mock tests:**
   Execute this SQL in the Supabase SQL Editor:

   ```sql
   -- Enable RLS on any tables that need protection
   ALTER TABLE public.mock_1 ENABLE ROW LEVEL SECURITY;
   ALTER TABLE public.mock_2 ENABLE ROW LEVEL SECURITY;
   ALTER TABLE public.mock_3 ENABLE ROW LEVEL SECURITY;
   ALTER TABLE public.mock_4 ENABLE ROW LEVEL SECURITY;

   -- Create policies for regular users (who have paid)
   CREATE POLICY "Allow paid users to access mock tests"
   ON public.mock_1
   FOR SELECT
   USING (
     EXISTS (
       SELECT 1 FROM public.profiles
       WHERE profiles.id = auth.uid() AND profiles.has_paid = true
     )
   );

   -- Repeat for other mock test tables (mock_2, mock_3, etc.)
   ```

### 9.4. Deployment Steps

1. Deploy the Supabase Edge Functions:

   ```bash
   # From the project root
   cd supabase/functions

   # Deploy the create-order function
   supabase functions deploy create-razorpay-order --no-verify-jwt

   # Deploy the verify-payment function
   supabase functions deploy verify-razorpay-payment --no-verify-jwt
   ```

2. Set up Supabase secrets:

   ```bash
   supabase secrets set RAZORPAY_KEY_ID=your_razorpay_key_id
   supabase secrets set RAZORPAY_KEY_SECRET=your_razorpay_key_secret
   ```

3. Update the frontend with the new context and components

### 9.5. Testing Checklist

- [ ] Verify the payment button appears for non-paid users
- [ ] Test order creation with the Edge Function
- [ ] Test the Razorpay payment flow with test credentials
- [ ] Verify payment verification with the Edge Function
- [ ] Check that the profile's `has_paid` field updates correctly
- [ ] Test RLS policies to ensure paid content is protected properly
- [ ] Verify that UI updates appropriately after successful payment

---
